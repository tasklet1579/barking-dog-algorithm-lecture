### 연결 리스트

1. 정의와 성질
2. 기능과 구현
3. STL vector
4. 연습 문제

### 1. 정의와 성질
1.1 정의

원소를 저장할 때 그 다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료구조

1.2 성질
- k번째 원소를 확인/변경하기 위해 O(k)가 필요함
  - 배열과 다르게 공간에 원소들이 연속해서 위치하고 있지 않기 때문
- 임의의 위치에 원소를 추가/임의 위치의 원소 제거는 O(1)
- 원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움

1.3 종류

단일 연결 리스트
```
각 원소가 다음 원소의 주소를 들고 있는 연결 리스트
```

이중 연결 리스트
```
각 원소가 자신의 이전 원소와 다음 원소의 주소를 들고 있음
원소가 가지고 있어야 하는 정보가 1개 더 추가되니 메모리를 더 쓴다는 단점이 있음
```

원형 연결 리스트
```
처음과 끝이 연결되어 있는 연결 리스트
각 원소가 이전과 다음 원소의 주소를 모두 들고 있어도 상관 없음
```

배열과 연결 리스트는 메모리 상에 원소를 놓는 방법이 다르다고 해도 원소들 사이의 선후 관계가 일대일로 정의되기 때문에 선형 자료구조라고 불린다

1.4 배열 vs 연결 리스트

| |배열|연결 리스트|
|---|---|---|
|k번째 원소의 접근|O(1)|O(k)|
|임의의 위치에 원소 추가/제거|O(N)|O(1)|
|메모리 상의 배치|연속|불연속|
|추가적으로 필요한 공간(Overhead)|-|O(N)|

연결 리스트는 임의의 위치까지 도달하는 시간이 존재하고 원소를 가리키는 주소 공간이 필요하다

### 2. 기능과 구현
- 임의의 위치에 있는 원소를 확인/변경, O(N)
- 임의의 위치에 원소를 삽입/삭제, O(1)
  - 삽입/삭제 연산이 많은 경우 연결 리스트의 사용을 고려해보자

2.1 야매 연결 리스트
```
const int SIZE = 1000005;
int data[SIZE], prev[SIZE], next[SIZE];
int unused = 1; // 새로운 원소가 들어갈 수 있는 위치, 0번지는 연결 리스트의 시작점이자 dummy node

fill(prev, prev + SIZE, -1); 
fill(next, next + SIZE, -1);
```
dummy node가 존재하는 이유는 삽입/삭제 등의 기능을 구현할 때 원소가 없는 경우에 대한 예외처리가 수월하기 때문
