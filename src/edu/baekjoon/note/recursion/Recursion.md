### 재귀

1. 알고리즘 설명
2. 연습 문제 1 - 거듭제곱
3. 연습 문제 2 - 하노이 탑
4. 연습 문제 3 - Z

### 1. 알고리즘 설명
1.1 재귀

하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

1.2 수학적 귀납법

어떤 문제를 재귀로 푼다는 것은 곧 귀납적인 방식으로 문제를 해결하겠다는 것

귀납적인 방식이란 것은 지금까지 우리의 상식과 큰 차이가 있다

예를 들어 어떤 문자열이 올바른 괄호 쌍인지 판단하는 문제가 있다면 여는 괄호가 나왔을 때 스택에 넣고 닫는 괄호가 나온다면 스택이 비어있는지? 스택의 top과 짝이 맞는지?를 확인해서 각각의 상황에 따라 동작하는 코드를 작성했다

이런 방식과 귀납적인 방식이 어떤 차이가 있는지 도미노를 통해 알아보자

제일 앞의 도미노를 쓰러트리게 되면 모든 도미노가 쓰러진다

그런데 왜 모든 도미노가 쓰러지는지를 설명해보라고 한다면 두 가지 방법이 있다

첫 번째 설명

1번 도미노가 쓰러지면 2번 도미노가 쓰러지고

2번 도미노가 쓰러지면 3번 도미노가 쓰러지고

3번 도미노가 쓰러지면 4번 도니모가 쓰러지고

이런 식으로 계속 진행되기 때문에 모든 도미노가 쓰러진다

두 번째 설명

1번 도미노가 쓰러진다

k번 도미노가 쓰러지면 k+1번 도미너도 쓰러진다가 참이니깐 모든 도미노가 쓰러진다

두 번째 설명 방법이 맞는 이유도 결국 1번 도미노가 쓰러지고 이후에 2번 도미노가 쓰러지고 이렇게 연쇄적으로 진행되어 모든 도미노가 쓰러지기 때문

하지만 앞으로는 1번 도미노가 쓰러진다

k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다 까지만 생각한 후에 모든 도미노가 쓰러진다는 결론에 도달할 수 있어야 한다

즉, 지금까지 당연하게 생각하던 절차지향적인 사고를 탈피해야 한다
```
n부터 1까지 출력하는 문제에서 절차지향적 사고와 귀납적 사고의 차이

절차지향적 사고
func1(3) 호출
↓
3 출력
↓
func1(2) 호출
↓
2 출력
↓
func1(1) 호출
↓
1 출력
↓
func1(0) 호출

귀납적 사고
func1(1)이 1을 출력
...
func1(k)가 k k-1 k-2 ... 1을 출력
func1(k+1)은 k+1 k k-1 ... 1을 출력

func1(k)가 k, k-1, k-2 ... 1을 출력하면 즉 k부터 1까지 차례대로 출력하면
func1(k+1)은 k+1부터 1까지 차례로 출력한다는 것을 증명한다

func1(k+1)이 호출될 때 어떤 상황이 발생하는가?
↓
k+1 출력
↓
func1(k) 호출
```

func1(k)는 k부터 1까지 차례로 출력한다 가정을 했으니 func1(k+1)은 k+1부터 1까지 차례대로 출력함을 알 수 있다

이 두 문장이 참이므로 귀납적으로 func1 함수가 n부터 1까지 차례로 출력하는 함수임을 알 수 있다

1.3 재귀 함수의 조건

특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함
- 모든 입력은 Base condition으로 수렴해야 함

1.4 재귀에 대한 정보 1

함수의 인자로 어떤 것을 받고 어디까지 계산한 후 자기 자신에게 넘겨줄지 명확하게 정해야 함

모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음

재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리/시간에서는 손해를 봄
> 재귀에서는 함수를 명확하게 정의해야 한다  
> 정의라는 것은 함수의 인자로 어떤 것을 받을지, 그리고 어디까지 계산한 후 자기 자신에게 넘겨줄지를 의미한다  
> 재귀는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있다  
> 재귀는 적재적소에 사용하면 코드가 간결해지지만 함수 호출이 꽤 비용이 큰 연산이기 때문에 메모리와 시간에서 손해를 본다    
> 굳이 재귀를 쓰지 않아도 구현에 큰 어려움이 없으면 재귀 대신 반복문으로 코드를 작성하는게 좋지만 재귀없이 구현을 하면 코드가 너무 복잡해지는 일부 문제들은 재귀로 구현을 하는게 좋다

1.5 재귀에 대한 정보 2

한 함수가 자기 자신을 여러번 호출하게 되면 비효율적일 수 있음

n번째 피보나치 항을 구하기 위해 필요한 연산의 횟수를 생각해보면 앞에서부터 차례로 1 1 2 3 5 8 ... 이렇게 가면 n번의 덧셈이 필요하다

그런데 fibo() 함수의 시간복잡도는 놀랍게도 O(1.618ⁿ) n이 100 정도만 되어도 일반 컴퓨터로 거의 20,000년 넘게 걸린다

1.618이라는 값이 조금 뜬금없어보일 수 있는데 n에 대한 지수함수 만큼의 시간이 걸린다는 것을 기억하자

왜 이런 일이 발생한지는 함수의 호출이 어떤식으로 이루어지는지 보면 되는데 fibo(5)를 예로 설명해보자
```
fibo(5) 호출
↓
fibo(4) fibo(3) 호출
↓
fibo(4)는 fibo(3) fibo(2) 호출
fibo(3)은 fibo(2) fibo(1) 호출
↓
fibo(3)은 fibo(2) fibo(1) 호출
fibo(2)는 fibo(1) fibo(0) 호출
fibo(2)는 fibo(1) fibo(0) 호출
↓
fibo(2)는 fibo(1) fibo(0) 호출
```

전체적인 상황을 보면 이미 계산한 것을 다시 계산하는 일이 빈번함을 알 수 있다

fibo(3)만 보더라도 왼쪽 오른쪽에서 두 번 계산하고 있다

이렇게 이미 계산한 값을 다시 계산하는 일이 빈번하게 발생해서 시간복잡도가 말도 안되게 커졌다

이와 같이 한 함수가 자기 자신을 여러번 호출할 경우에는 시간복잡도가 이상하게 될 수 있어서 조심해야 한다

피보나치 문제는 재귀 대신 나중에 배울 다이나믹 프로그래밍으로 O(n)에 해결할 수 있다

1.6 재귀에 대한 정보 3

재귀함수가 자기 자신을 부를 때 스택 영역에 계속 누적이 됨

스택 영역이라고 하는 것은 메모리 구조에서의 스택 영역을 말한다

1.7 문제에서의 메모리 제한

프로그램이 점유하는 최대 메모리 크기

일부 컴파일 환경에서는 스택 영역의 메모리가 별도로 1MB로 제한되어 있기도 함
- Visual Studio 2017/2019 1MB
- GCC+MingW 1MB
- Linux 8MB 또는 10MB
- 일부 채점 사이트

재귀를 10만번 정도만 들어가도 스택 메모리에 함수에 대한 정보가 계속 쌓이다가 1MB를 넘겨서 제출해보면 런타임 에러가 발생한다

스택 메모리가 작게 제한된 곳에서 문제를 푸는데 본인의 풀이가 재귀를 깊게 들어간다면 재귀 대신 반복문으로 풀어야 하고 스택 메모리에는 지역 변수도 들어간다
