### 기초 코드 작성 요령 Ⅰ

1. 시간, 공간복잡도
2. 정수 자료형
3. 실수 자료형

### 1. 시간, 공간복잡도
컴퓨터는 1초에 대략 3-5억 개 정도의 연산을 처리할 수 있다
단, 연산이 비트 AND, OR, 비교, 덧셈과 같은 단순한 연산인지 아니면 나눗셈, 곱셉, 대입, 함수 호출과 같은 복잡한 연산인지에 따라 횟수는 조금 차이가 날 수 있다
문제에서 시간 제한이 1초라는 것은 알고리즘이 3-5억 번의 연산 안에 답을 내고 종료되어야 함을 뜻한다

아래의 함수는 몇 번의 연산을 수행하는지 확인하자
```
int func1(int[] arr, int n) {
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] % 5 == 0) cnt++;
    }
    return cnt;
}

cnt 변수를 선언하고 0을 넣는 과정에서 1번
i 변수를 선언하고 0을 넣는 과정에서 1번
그 다음은 n번에 걸쳐 반복되는 일인데
i가 n보다 작은지 확인하고 작을 경우 1 증가시키는 과정에서 2번
5로 나눈 나머지를 계산하고 나머지가 0과 일치하는지 확인하는 과정에서 2번
cnt를 1 증가시키는 과정에서 1번
마지막으로 cnt를 반환하는 과정에서 1번

이 함수는 5n + 3번의 연산이 필요하다는 것을 알 수 있다
n이 10억이었으면 대충 50억 번의 연산이 필요하니 1초를 초과한다

결국 n개의 숫자를 확인하며 5로 나눈 나머지를 계산해보기 때문에
5n + 3이라는 것을 알아내지 않더라도 n에 비례한다는 것을 생각할 수 있다
```

문제
```
대회장에 N명의 사람들이 일렬로 서있다
거기서 당신은 이름이 '가나다'인 사람을 찾기 위해 사람들에게 이름을 물어볼 것이다
이름을 물어보고 대답을 듣는데까지 1초가 걸린다면 얼마만큼의 시간이 필요할까?
```
정답
```
앞에서부터 차례대로 물어보면 된다
최악의 경우 N초, 최선의 경우 1초, 평균적으로 N/2초가 필요하다
걸리는 시간은 N에 비례한다
```

문제
```
대회장에 N명의 사람들이 일렬로 서있다
거기서 당신은 이름이 '가나다'인 사람을 찾기 위해 사람들에게 이름을 물어볼 것이다
이 때 사람들은 이름 순으로 서 있다
이름을 물어보고 대답을 듣는데까지 1초가 걸린다면 얼마만큼의 시간이 필요할까?
```
정답
```
업다운 게임을 하듯이 중간 사람에게 계속 물어보면 된다
최선의 경우 1초, 최악의 경우 logN초, 평균적으로 logN초가 필요하다
걸리는 시간은 logN에 비례한다
```

시간복잡도 (Time Complexity)
```
입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계
```
빅오표기법 (Big-O Notation)
```
주어진 식을 값이 가장 큰 대표항만 남겨서 나타내는 방법
```
문제에서 주어지는 시간 제한은 대부분 1초에서 5초 사이 정도니까 입력의 범위를 보고 문제에서 요구하는 시간복잡도를 예측할 수 있다

|N의 크기|허용 시간 복잡도|
|---|---|
|N ≤ 11|O(n!)|
|N ≤ 25|O(2ⁿ)|
|N ≤ 100|O(n⁴)|
|N ≤ 500|O(n³)|
|N ≤ 3,000|O(n²logN)|
|N ≤ 5,000|O(n²)|
|N ≤ 1,000,000|O(nlogN)|
|N ≤ 10,000,000|O(n)|
|그 이상|O(logN), O(1)|    

이 기준이 절대적인 것은 아니다 복잡한 연산이 많은 경우 통과되지 않을 수도 있다

주어진 문제를 보고 풀이를 떠올린 후에 제한 시간 내에 통과할 수 있는지 생각해 보자

공간복잡도 (Space Complexity)
```
입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계
```
※ 메모리 제한이 512MB일 때 int 변수를 대략 1.2억개 정도 선언할 수 있다

### 2. 정수 자료형
char 자료형의 값은 8개의 0 혹은 1이 들어가는 칸을 이용해 표현된다

※ two's complement 개념을 찾아보자

unsigned char
```
0 0 0 0 1 0 0 1 → 9
1 0 0 0 0 0 1 1 → 13
```

char
```
0 0 0 0 1 0 0 1 → 9
1 0 0 0 0 0 1 1 → -125
```

표현할 수 있는 최댓값
```
char          (1byte) 2⁷  - 1 (=127)
unsigned char (1byte) 2⁸  - 1 (=255)
short         (2byte) 2¹⁵ - 1 (=32767)
int           (4byte) 2³¹ - 1 (≒2.1 * 10⁹)
long          (8byte) 2⁶³ - 1 (≒9.2 * 10¹⁸)
```

Integer Overflow
```
int a = 2000000000 * 2;
System.out.print(a); // -294967296
```

Overflow가 발생하는 이유를 알아보자
```
0 0 0 0 1 0 0 1 → 9
0 0 0 1 0 1 0 1 → 21
0 0 0 1 1 1 1 0 → 30

1 0 0 0 1 0 0 1 → -119
0 0 0 0 0 1 0 1 → 5
1 0 0 0 1 1 1 0 → -114

0 1 1 1 1 1 1 1 → 127
0 0 0 0 0 0 0 1 → 1
1 0 0 0 0 0 0 0 → -128
```

컴퓨터는 명령받은 대로 이진수 계산을 하고 그 결과는 예상과 다를 수 있다

각 자료형의 범위에 맞는 값을 가지게끔 연산을 시키자

### 3. 실수 자료형
3.1 float, double

32칸 혹은 64칸으로 실수를 나타낸다는 건데 대체 어떻게 실수를 표현할까?

컴퓨터가 실수를 어떻게 저장하는지 알려면 우선 2진수를 실수로 확장하는 것을 이해해야 한다

```
3.75 = 2 + 1 + 0.5 + 0.25 = 2¹ + 2⁰ + 2⁻¹ + 2⁻² = 11.11₍₂₎
1/3 = 2⁻² + 2⁻⁴ + 2⁻⁶ + 2⁻⁸ + ··· = 0.010101···₍₂₎
```
2의 음수 거듭제곱을 이용해 임의의 실수를 2진수로 나타낼 수 있다

2진수에서의 과학적 표기법 이해

10진수 3561.234를 편의를 위해 3.561234 x 10³으로 나타내는 것처럼 2진수에서도 11101.001₍₂₎를 1.1101001₍₂₎ x 2⁴으로 나타낼 수 있다
```
float  sign(1) exponent(8)  fraction(23)
double sign(1) exponent(11) fraction(52)
```

실수를 저장할 때 칸은 sign, exponent, fraction 필드로 나뉜다

sign은 해당 수가 음수인지 양수인지 저장하는 필드

exponent는 과학적 표기법에서의 지수를 저장하는 필드

fraction은 유효숫자 부분을 저장하는 필드

-6.75 = -1.1011₍₂₎ x 2²
-6.75의 부호가 음수여서 sign은 1
2의 거듭제곱이니 지수는 2인데 여기에 127을 더한 129를 exponent에 기록한다 (129는 2진수로 1 0 0 0 0 0 0 1)
127를 더해주는 이유는 이렇게 해야 음수의 제곱도 exponent에 기록할 수 있다

fraction에는 유한소수 1011를 기록한다
fraction의 첫번째부터 2⁻¹, 2⁻², 2⁻³ ... 자리를 의미한다

이렇게 실수를 저장하는 방식을 IEEE-754 format이라고 부른다

3.2 실수의 성질

첫째, 실수의 저장/연산 과정에서 반드시 오차가 발생할 수 밖에 없다
```
0.1 + 0.1 + 0.1과 0.3은 같지 않다
유효숫자가 들어가는 fraction 필드가 유한하기 때문에 2진수 기준으로 무한소수는 float은 23 bit, double은 52 bit까지만 저장한다
0.1은 2진수로 나타내면 무한소수여서 애초에 오차가 있는 채로 저장이 됐고 3번 더하다보니 오차가 더 커졌다

fraction 필드를 가지고 각 자료형이 어디까지 정확하게 표현할 수 있는지 확인해 보면 float은 유효숫자가 6자리, double은 유효숫자가 15자리이기 때문에
float은 상대 오차가 10⁻⁶까지 안전하고 double은 10⁻¹⁵까지 안전한 것을 알 수 있다

상대 오차가 10⁻¹⁵까지 안전하다는 표현은 참값이 1이라고할 때 1 - 10⁻¹⁵에서 1 + 10⁻¹⁵ 사이의 값을 가진다는게 보장된다는 의미이다
오차가 생기는 것 자체는 막을 수가 없지만 오차가 어느 정도인지는 알 수 있다

상대 오차의 허용 범위에서 볼 수 있듯이 두 자료형의 차이가 굉장히 크기 때문에 실수 자로형이 필요하면 float 대신 double을 사용해야 한다
float이 메모리를 적게 쓴다는 장점이 있지만 문제를 풀면서 float을 사용해야 하는 상황을 경험해본 적이 없다

실수 자료형은 필연적으로 오차가 존재하니 실수 자료형이 필요한 문제면 절대/상대 오차를 허용한다는 단서를 준다
만약 이러한 표현이 없다면 열에 아홉은 실수를 안 쓰고 모든 연산을 정수에서 해결할 수 있는 문제일 것이다
```

둘째, double에 long 범위의 정수를 함부로 담으면 안된다
```
double 보다 long의 유효숫자가 더 크기 때문에 오차가 섞인 값이 저장될 수 있다
다만 int는 최대 21억이기 때문에 double에 담아도 오차가 생기지 않는다
```

셋째, 실수를 비교할 때는 등호를 사용하면 안된다
```
오차 때문에 두 실수가 같은지 알고 싶을 때는 둘의 차이가 아주 작은 값
대략 10⁻¹² 이하면 동일하다고 처리를 하는게 안전하다
```
